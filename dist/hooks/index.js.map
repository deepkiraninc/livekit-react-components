{"version":3,"sources":["../../src/hooks/index.ts","../../src/hooks/useDataChannel.ts","../../src/context/layout-context.ts","../../src/context/participant-context.ts","../../src/context/track-context.ts","../../src/context/room-context.ts","../../src/hooks/internal/useResizeObserver.ts","../../src/hooks/internal/useObservableState.ts","../../src/hooks/useGridLayout.ts","../../src/hooks/useIsMuted.ts","../../src/hooks/useIsSpeaking.ts","../../src/hooks/useLocalParticipant.ts","../../src/hooks/useLocalParticipantPermissions.ts","../../src/hooks/useMediaTrackBySourceOrName.ts","../../src/utils.ts","../../src/mergeProps.ts","../../src/hooks/useMediaTrack.ts","../../src/hooks/useMediaTrackByName.ts","../../src/hooks/usePagination.ts","../../src/hooks/useVisualStableUpdate.ts","../../src/hooks/useParticipantPermissions.ts","../../src/hooks/useRemoteParticipants.ts","../../src/hooks/useParticipants.ts","../../src/hooks/useRemoteParticipant.ts","../../src/hooks/useSortedParticipants.ts","../../src/hooks/useSpeakingParticipants.ts","../../src/hooks/useToken.ts","../../src/hooks/useTracks.ts","../../src/hooks/usePinnedTracks.ts","../../src/hooks/useSwipe.ts"],"sourcesContent":["export { useDataChannel } from './useDataChannel';\r\nexport { useGridLayout } from './useGridLayout';\r\nexport { useIsMuted, UseIsMutedOptions } from './useIsMuted';\r\nexport { useIsSpeaking } from './useIsSpeaking';\r\nexport { useLocalParticipant, UseLocalParticipantOptions } from './useLocalParticipant';\r\nexport { useLocalParticipantPermissions } from './useLocalParticipantPermissions';\r\nexport { useMediaTrack, UseMediaTrackOptions } from './useMediaTrack';\r\nexport { useMediaTrackByName } from './useMediaTrackByName';\r\nexport { usePagination } from './usePagination';\r\nexport {\r\n  useParticipantPermissions,\r\n  UseParticipantPermissionsOptions,\r\n} from './useParticipantPermissions';\r\nexport { useParticipants, UseParticipantsOptions } from './useParticipants';\r\nexport { useRemoteParticipant, UseRemoteParticipantOptions } from './useRemoteParticipant';\r\nexport { useRemoteParticipants, UseRemoteParticipantsOptions } from './useRemoteParticipants';\r\nexport { useSortedParticipants } from './useSortedParticipants';\r\nexport { useSpeakingParticipants } from './useSpeakingParticipants';\r\nexport { useToken, UseTokenOptions, UserInfo } from './useToken';\r\nexport { useTracks, UseTracksOptions, UseTracksHookReturnType } from './useTracks';\r\nexport { useVisualStableUpdate, UseVisualStableUpdateOptions } from './useVisualStableUpdate';\r\nexport { usePinnedTracks } from './usePinnedTracks';\r\nexport { useSwipe, UseSwipeOptions } from './useSwipe';\r\n","import type { ReceivedDataMessage } from '@livekit/components-core';\r\nimport { setupDataMessageHandler } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useRoomContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/** @public */\r\nexport function useDataChannel<T extends string>(\r\n  topic?: T,\r\n  onMessage?: (msg: ReceivedDataMessage<T>) => void,\r\n) {\r\n  const room = useRoomContext();\r\n  const { send, messageObservable, isSendingObservable } = React.useMemo(\r\n    () => setupDataMessageHandler(room, topic, onMessage),\r\n    [room, topic, onMessage],\r\n  );\r\n\r\n  const message = useObservableState(messageObservable, undefined);\r\n  const isSending = useObservableState(isSendingObservable, false);\r\n\r\n  return {\r\n    message,\r\n    send,\r\n    isSending,\r\n  };\r\n}\r\n","import { PIN_DEFAULT_STATE, WIDGET_DEFAULT_STATE } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport type { PinContextType } from './pin-context';\r\nimport type { ChatContextType } from './chat-context';\r\nimport { chatReducer } from './chat-context';\r\nimport { pinReducer } from './pin-context';\r\n\r\n/** @public */\r\nexport type LayoutContextType = {\r\n  pin: PinContextType;\r\n  widget: ChatContextType;\r\n};\r\n\r\n/** @public */\r\nexport const LayoutContext = React.createContext<LayoutContextType | undefined>(undefined);\r\n\r\n/**\r\n * Ensures that a layout context is provided via context.\r\n * If no layout context is provided, an error is thrown.\r\n * @public\r\n */\r\nexport function useLayoutContext(): LayoutContextType {\r\n  const layoutContext = React.useContext(LayoutContext);\r\n  if (!layoutContext) {\r\n    throw Error('Tried to access LayoutContext context outside a LayoutContextProvider provider.');\r\n  }\r\n  return layoutContext;\r\n}\r\n\r\n/**\r\n * Ensures that a layout context is provided, either via context or explicitly as a parameter.\r\n * If not inside a `LayoutContext` and no layout context is provided, an error is thrown.\r\n * @public\r\n */\r\nexport function useEnsureLayoutContext(layoutContext?: LayoutContextType) {\r\n  const layout = useMaybeLayoutContext();\r\n  layoutContext ??= layout;\r\n  if (!layoutContext) {\r\n    throw Error('Tried to access LayoutContext context outside a LayoutContextProvider provider.');\r\n  }\r\n  return layoutContext;\r\n}\r\n\r\n/** @public */\r\nexport function useCreateLayoutContext(): LayoutContextType {\r\n  const [pinState, pinDispatch] = React.useReducer(pinReducer, PIN_DEFAULT_STATE);\r\n  const [widgetState, widgetDispatch] = React.useReducer(chatReducer, WIDGET_DEFAULT_STATE);\r\n  return {\r\n    pin: { dispatch: pinDispatch, state: pinState },\r\n    widget: { dispatch: widgetDispatch, state: widgetState },\r\n  };\r\n}\r\n\r\n/** @public */\r\nexport function useEnsureCreateLayoutContext(layoutContext?: LayoutContextType): LayoutContextType {\r\n  const [pinState, pinDispatch] = React.useReducer(pinReducer, PIN_DEFAULT_STATE);\r\n  const [widgetState, widgetDispatch] = React.useReducer(chatReducer, WIDGET_DEFAULT_STATE);\r\n\r\n  return (\r\n    layoutContext ?? {\r\n      pin: { dispatch: pinDispatch, state: pinState },\r\n      widget: { dispatch: widgetDispatch, state: widgetState },\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Returns a layout context from the `LayoutContext` if it exists, otherwise `undefined`.\r\n * @public\r\n */\r\nexport function useMaybeLayoutContext(): LayoutContextType | undefined {\r\n  return React.useContext(LayoutContext);\r\n}\r\n","import type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useMaybeTrackContext } from './track-context';\r\n\r\n/** @public */\r\nexport const ParticipantContext = React.createContext<Participant | undefined>(undefined);\r\n\r\n/**\r\n * Ensures that a participant is provided via context.\r\n * If not inside a `ParticipantContext`, an error is thrown.\r\n * @public\r\n */\r\nexport function useParticipantContext() {\r\n  const participant = React.useContext(ParticipantContext);\r\n  if (!participant) {\r\n    throw Error('tried to access participant context outside of participant context provider');\r\n  }\r\n  return participant;\r\n}\r\n\r\n/**\r\n * Returns a participant from the `ParticipantContext` if it exists, otherwise `undefined`.\r\n * @public\r\n */\r\nexport function useMaybeParticipantContext() {\r\n  return React.useContext(ParticipantContext);\r\n}\r\n\r\n/**\r\n * Ensures that a participant is provided, either via context or explicitly as a parameter.\r\n * If not inside a `ParticipantContext` and no participant is provided, an error is thrown.\r\n * @public\r\n */\r\nexport function useEnsureParticipant(participant?: Participant) {\r\n  const context = useMaybeParticipantContext();\r\n  const trackContext = useMaybeTrackContext();\r\n  const p = participant ?? context ?? trackContext?.participant;\r\n  if (!p) {\r\n    throw new Error(\r\n      'No participant provided, make sure you are inside a participant context or pass the participant explicitly',\r\n    );\r\n  }\r\n  return p;\r\n}\r\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\r\nimport * as React from 'react';\r\n\r\n/** @public */\r\nexport const TrackContext = React.createContext<TrackReferenceOrPlaceholder | undefined>(undefined);\r\n\r\n/**\r\n * Ensures that a track reference is provided via context.\r\n * If not inside a `TrackContext`, an error is thrown.\r\n * @public\r\n */\r\nexport function useTrackContext() {\r\n  const trackReference = React.useContext(TrackContext);\r\n  if (!trackReference) {\r\n    throw Error('tried to access track context outside of track context provider');\r\n  }\r\n  return trackReference;\r\n}\r\n\r\n/**\r\n * Returns a track reference from the `TrackContext` if it exists, otherwise `undefined`.\r\n * @public\r\n */\r\nexport function useMaybeTrackContext() {\r\n  return React.useContext(TrackContext);\r\n}\r\n\r\n/**\r\n * Ensures that a track reference is provided, either via context or explicitly as a parameter.\r\n * If not inside a `TrackContext` and no track reference is provided, an error is thrown.\r\n * @public\r\n */\r\nexport function useEnsureTrackReference(track?: TrackReferenceOrPlaceholder) {\r\n  const context = useMaybeTrackContext();\r\n  const trackRef = track ?? context;\r\n  if (!trackRef) {\r\n    throw new Error(\r\n      'No TrackReference provided, make sure you are inside a track context or pass the track reference explicitly',\r\n    );\r\n  }\r\n  return trackRef;\r\n}\r\n","import type { Room } from 'livekit-client';\r\nimport * as React from 'react';\r\n\r\n/** @public */\r\nexport const RoomContext = React.createContext<Room | undefined>(undefined);\r\n\r\n/**\r\n * Ensures that a room is provided via context.\r\n * If no room is provided, an error is thrown.\r\n * @public\r\n */\r\nexport function useRoomContext() {\r\n  const ctx = React.useContext(RoomContext);\r\n  if (!ctx) {\r\n    throw Error('tried to access room context outside of livekit room component');\r\n  }\r\n  return ctx;\r\n}\r\n\r\n/**\r\n * Returns the room context if it exists, otherwise undefined.\r\n * @public\r\n */\r\nexport function useMaybeRoomContext() {\r\n  return React.useContext(RoomContext);\r\n}\r\n\r\n/**\r\n * Ensures that a room is provided, either via context or explicitly as a parameter.\r\n * If no room is provided, an error is thrown.\r\n * @public\r\n */\r\nexport function useEnsureRoom(room?: Room) {\r\n  const context = useMaybeRoomContext();\r\n  const r = room ?? context;\r\n  if (!r) {\r\n    throw new Error(\r\n      'No room provided, make sure you are inside a Room context or pass the room explicitly',\r\n    );\r\n  }\r\n  return r;\r\n}\r\n","/* eslint-disable no-return-assign */\r\n/* eslint-disable no-underscore-dangle */\r\nimport * as React from 'react';\r\nimport useLatest from '@react-hook/latest';\r\n\r\n/**\r\n * A React hook that fires a callback whenever ResizeObserver detects a change to its size\r\n * code extracted from https://github.com/jaredLunde/react-hook/blob/master/packages/resize-observer/src/index.tsx in order to not include the polyfill for resize-observer\r\n *\r\n * @internal\r\n */\r\nexport function useResizeObserver<T extends HTMLElement>(\r\n  target: React.RefObject<T>,\r\n  callback: UseResizeObserverCallback,\r\n) {\r\n  const resizeObserver = getResizeObserver();\r\n  const storedCallback = useLatest(callback);\r\n\r\n  React.useLayoutEffect(() => {\r\n    let didUnsubscribe = false;\r\n\r\n    const targetEl = target.current;\r\n    if (!targetEl) return;\r\n\r\n    function cb(entry: ResizeObserverEntry, observer: ResizeObserver) {\r\n      if (didUnsubscribe) return;\r\n      storedCallback.current(entry, observer);\r\n    }\r\n\r\n    resizeObserver?.subscribe(targetEl as HTMLElement, cb);\r\n\r\n    return () => {\r\n      didUnsubscribe = true;\r\n      resizeObserver?.unsubscribe(targetEl as HTMLElement, cb);\r\n    };\r\n  }, [target.current, resizeObserver, storedCallback]);\r\n\r\n  return resizeObserver?.observer;\r\n}\r\n\r\nfunction createResizeObserver() {\r\n  let ticking = false;\r\n  let allEntries: ResizeObserverEntry[] = [];\r\n\r\n  const callbacks: Map<unknown, Array<UseResizeObserverCallback>> = new Map();\r\n\r\n  if (typeof window === 'undefined') {\r\n    return;\r\n  }\r\n\r\n  const observer = new ResizeObserver((entries: ResizeObserverEntry[], obs: ResizeObserver) => {\r\n    allEntries = allEntries.concat(entries);\r\n    if (!ticking) {\r\n      window.requestAnimationFrame(() => {\r\n        const triggered = new Set<Element>();\r\n        for (let i = 0; i < allEntries.length; i++) {\r\n          if (triggered.has(allEntries[i].target)) continue;\r\n          triggered.add(allEntries[i].target);\r\n          const cbs = callbacks.get(allEntries[i].target);\r\n          cbs?.forEach((cb) => cb(allEntries[i], obs));\r\n        }\r\n        allEntries = [];\r\n        ticking = false;\r\n      });\r\n    }\r\n    ticking = true;\r\n  });\r\n\r\n  return {\r\n    observer,\r\n    subscribe(target: HTMLElement, callback: UseResizeObserverCallback) {\r\n      observer.observe(target);\r\n      const cbs = callbacks.get(target) ?? [];\r\n      cbs.push(callback);\r\n      callbacks.set(target, cbs);\r\n    },\r\n    unsubscribe(target: HTMLElement, callback: UseResizeObserverCallback) {\r\n      const cbs = callbacks.get(target) ?? [];\r\n      if (cbs.length === 1) {\r\n        observer.unobserve(target);\r\n        callbacks.delete(target);\r\n        return;\r\n      }\r\n      const cbIndex = cbs.indexOf(callback);\r\n      if (cbIndex !== -1) cbs.splice(cbIndex, 1);\r\n      callbacks.set(target, cbs);\r\n    },\r\n  };\r\n}\r\n\r\nlet _resizeObserver: ReturnType<typeof createResizeObserver>;\r\n\r\nconst getResizeObserver = () =>\r\n  !_resizeObserver ? (_resizeObserver = createResizeObserver()) : _resizeObserver;\r\n\r\nexport type UseResizeObserverCallback = (\r\n  entry: ResizeObserverEntry,\r\n  observer: ResizeObserver,\r\n) => unknown;\r\n\r\nexport const useSize = (target: React.RefObject<HTMLDivElement>) => {\r\n  const [size, setSize] = React.useState({ width: 0, height: 0 });\r\n  React.useLayoutEffect(() => {\r\n    if (target.current) {\r\n      const { width, height } = target.current.getBoundingClientRect();\r\n      setSize({ width, height });\r\n    }\r\n  }, [target.current]);\r\n\r\n  const resizeCallback = React.useCallback(\r\n    (entry: ResizeObserverEntry) => setSize(entry.contentRect),\r\n    [],\r\n  );\r\n  // Where the magic happens\r\n  useResizeObserver(target, resizeCallback);\r\n  return size;\r\n};\r\n","import * as React from 'react';\r\nimport type { Observable } from 'rxjs';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function useObservableState<T>(observable: Observable<T> | undefined, startWith: T) {\r\n  const [state, setState] = React.useState<T>(startWith);\r\n  React.useEffect(() => {\r\n    // observable state doesn't run in SSR\r\n    if (typeof window === 'undefined' || !observable) return;\r\n    const subscription = observable.subscribe(setState);\r\n    return () => subscription.unsubscribe();\r\n  }, [observable]);\r\n  return state;\r\n}\r\n","import { GRID_LAYOUTS, selectGridLayout } from '@livekit/components-core';\r\nimport type { GridLayout } from '@livekit/components-core/dist/helper/grid-layouts';\r\nimport * as React from 'react';\r\nimport { useSize } from './internal';\r\n\r\n/**\r\n * The useGridLayout hook tries to select the best layout to fit all tiles.\r\n * If the available screen space is not enough, it will reduce the number of maximum visible\r\n * tiles and select a layout that still works visually within the given limitations.\r\n * As the order of tiles changes over time, the hook tries to keep visual updates to a minimum\r\n * while trying to display important tiles such as speaking participants or screen shares.\r\n * @public\r\n */\r\nexport function useGridLayout(\r\n  /** HTML element that contains the grid. */\r\n  gridElement: React.RefObject<HTMLDivElement>,\r\n  /** Count of tracks that should get layed out */\r\n  trackCount: number,\r\n): { layout: GridLayout } {\r\n  const { width, height } = useSize(gridElement);\r\n\r\n  const layout =\r\n    width > 0 && height > 0\r\n      ? selectGridLayout(GRID_LAYOUTS, trackCount, width, height)\r\n      : GRID_LAYOUTS[0];\r\n\r\n  React.useEffect(() => {\r\n    if (gridElement.current && layout) {\r\n      gridElement.current.style.setProperty('--lk-col-count', layout?.columns.toString());\r\n      gridElement.current.style.setProperty('--lk-row-count', layout?.rows.toString());\r\n    }\r\n  }, [gridElement, layout]);\r\n\r\n  return {\r\n    layout,\r\n  };\r\n}\r\n","import { mutedObserver } from '@livekit/components-core';\r\nimport type { Participant, Track } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureParticipant } from '../context';\r\n\r\n/** @public */\r\nexport interface UseIsMutedOptions {\r\n  participant?: Participant;\r\n}\r\n\r\n/** @public */\r\nexport function useIsMuted(source: Track.Source, options: UseIsMutedOptions = {}) {\r\n  const p = useEnsureParticipant(options.participant);\r\n  const [isMuted, setIsMuted] = React.useState(!!p.getTrack(source)?.isMuted);\r\n\r\n  React.useEffect(() => {\r\n    const listener = mutedObserver(p, source).subscribe(setIsMuted);\r\n    return () => listener.unsubscribe();\r\n  }, [p, source]);\r\n\r\n  return isMuted;\r\n}\r\n","import { createIsSpeakingObserver } from '@livekit/components-core';\r\nimport type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureParticipant } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/** @public */\r\nexport function useIsSpeaking(participant?: Participant) {\r\n  const p = useEnsureParticipant(participant);\r\n  const observable = React.useMemo(() => createIsSpeakingObserver(p), [p]);\r\n  const isSpeaking = useObservableState(observable, p.isSpeaking);\r\n\r\n  return isSpeaking;\r\n}\r\n","import type { ParticipantMedia } from '@livekit/components-core';\r\nimport { observeParticipantMedia } from '@livekit/components-core';\r\nimport type { TrackPublication, LocalParticipant, Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\n\r\n/** @public */\r\nexport interface UseLocalParticipantOptions {\r\n  /**\r\n   * The room to use. If not provided, the hook will use the room from the context.\r\n   */\r\n  room?: Room;\r\n}\r\n\r\n/**\r\n * The useLocalParticipant hook the state of the local participant.\r\n * @public\r\n */\r\nexport const useLocalParticipant = (options: UseLocalParticipantOptions = {}) => {\r\n  const room = useEnsureRoom(options.room);\r\n  const [localParticipant, setLocalParticipant] = React.useState(room.localParticipant);\r\n  const [isMicrophoneEnabled, setIsMicrophoneEnabled] = React.useState(\r\n    localParticipant.isMicrophoneEnabled,\r\n  );\r\n  const [isCameraEnabled, setIsCameraEnabled] = React.useState(\r\n    localParticipant.isMicrophoneEnabled,\r\n  );\r\n  const [isScreenShareEnabled, setIsScreenShareEnabled] = React.useState(\r\n    localParticipant.isMicrophoneEnabled,\r\n  );\r\n  const [microphoneTrack, setMicrophoneTrack] = React.useState<TrackPublication | undefined>(\r\n    undefined,\r\n  );\r\n  const [cameraTrack, setCameraTrack] = React.useState<TrackPublication | undefined>(undefined);\r\n\r\n  const handleUpdate = (media: ParticipantMedia<LocalParticipant>) => {\r\n    setIsCameraEnabled(media.isCameraEnabled);\r\n    setIsMicrophoneEnabled(media.isMicrophoneEnabled);\r\n    setIsScreenShareEnabled(media.isScreenShareEnabled);\r\n    setCameraTrack(media.cameraTrack);\r\n    setMicrophoneTrack(media.microphoneTrack);\r\n    setLocalParticipant(media.participant);\r\n  };\r\n  React.useEffect(() => {\r\n    const listener = observeParticipantMedia(localParticipant).subscribe(handleUpdate);\r\n    // TODO also listen to permission and metadata etc. events\r\n    return () => listener.unsubscribe();\r\n  }, [localParticipant]);\r\n\r\n  return {\r\n    isMicrophoneEnabled,\r\n    isScreenShareEnabled,\r\n    isCameraEnabled,\r\n    microphoneTrack,\r\n    cameraTrack,\r\n    localParticipant,\r\n  };\r\n};\r\n","import { participantPermissionObserver } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useRoomContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/** @public */\r\nexport function useLocalParticipantPermissions() {\r\n  const room = useRoomContext();\r\n  const permissionObserver = React.useMemo(\r\n    () => participantPermissionObserver(room.localParticipant),\r\n    [room],\r\n  );\r\n  const permissions = useObservableState(permissionObserver, room.localParticipant.permissions);\r\n  return permissions;\r\n}\r\n","import type { TrackIdentifier } from '@livekit/components-core';\r\nimport { isTrackReference } from '@livekit/components-core';\r\nimport { setupMediaTrack, log, isLocal, getTrackByIdentifier } from '@livekit/components-core';\r\nimport { Track } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { mergeProps } from '../utils';\r\nimport type { UseMediaTrackOptions } from './useMediaTrack';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function useMediaTrackBySourceOrName(\r\n  observerOptions: TrackIdentifier,\r\n  options: UseMediaTrackOptions = {},\r\n) {\r\n  const [publication, setPublication] = React.useState(getTrackByIdentifier(observerOptions));\r\n\r\n  const [isMuted, setMuted] = React.useState(publication?.isMuted);\r\n  const [isSubscribed, setSubscribed] = React.useState(publication?.isSubscribed);\r\n  const [track, setTrack] = React.useState(publication?.track);\r\n  const [orientation, setOrientation] = React.useState<'landscape' | 'portrait'>('landscape');\r\n  const previousElement = React.useRef<HTMLMediaElement | undefined | null>();\r\n\r\n  const { className, trackObserver } = React.useMemo(() => {\r\n    return setupMediaTrack(observerOptions);\r\n  }, [\r\n    observerOptions.participant.identity,\r\n    observerOptions.source,\r\n    isTrackReference(observerOptions) && observerOptions.publication.trackSid,\r\n  ]);\r\n\r\n  React.useEffect(() => {\r\n    const subscription = trackObserver.subscribe((publication) => {\r\n      log.debug('update track', publication);\r\n      setPublication(publication);\r\n      setMuted(publication?.isMuted);\r\n      setSubscribed(publication?.isSubscribed);\r\n      setTrack(publication?.track);\r\n    });\r\n    return () => subscription?.unsubscribe();\r\n  }, [trackObserver]);\r\n\r\n  React.useEffect(() => {\r\n    if (track) {\r\n      if (previousElement.current) {\r\n        track.detach(previousElement.current);\r\n      }\r\n      if (\r\n        options.element?.current &&\r\n        !(isLocal(observerOptions.participant) && track?.kind === 'audio')\r\n      ) {\r\n        track.attach(options.element.current);\r\n      }\r\n    }\r\n    previousElement.current = options.element?.current;\r\n    return () => {\r\n      if (previousElement.current) {\r\n        track?.detach(previousElement.current);\r\n      }\r\n    };\r\n  }, [track, options.element]);\r\n\r\n  React.useEffect(() => {\r\n    // Set the orientation of the video track.\r\n    // TODO: This does not handle changes in orientation after a track got published (e.g when rotating a phone camera from portrait to landscape).\r\n    if (\r\n      typeof publication?.dimensions?.width === 'number' &&\r\n      typeof publication?.dimensions?.height === 'number'\r\n    ) {\r\n      const orientation_ =\r\n        publication.dimensions.width > publication.dimensions.height ? 'landscape' : 'portrait';\r\n      setOrientation(orientation_);\r\n    }\r\n  }, [publication]);\r\n\r\n  return {\r\n    publication,\r\n    isMuted,\r\n    isSubscribed,\r\n    track,\r\n    elementProps: mergeProps(options.props, {\r\n      className,\r\n      'data-lk-local-participant': observerOptions.participant.isLocal,\r\n      'data-lk-source': publication?.source,\r\n      ...(publication?.source === Track.Source.Camera ||\r\n      publication?.source === Track.Source.ScreenShare\r\n        ? { 'data-lk-orientation': orientation }\r\n        : {}),\r\n    }),\r\n  };\r\n}\r\n","import * as React from 'react';\r\nimport { mergeProps as mergePropsReactAria } from './mergeProps';\r\n\r\n/** @internal */\r\nexport function isProp<U extends HTMLElement, T extends React.HTMLAttributes<U>>(\r\n  prop: T | undefined,\r\n): prop is T {\r\n  return prop !== undefined;\r\n}\r\n\r\n/** @internal */\r\nexport function mergeProps<\r\n  U extends HTMLElement,\r\n  T extends Array<React.HTMLAttributes<U> | undefined>,\r\n>(...props: T) {\r\n  return mergePropsReactAria(...props.filter(isProp));\r\n}\r\n\r\n// const merged = mergeProps({ className: 'test', 'data-lk-participant-name': 'my_name' });\r\n\r\n/** @internal */\r\nexport function cloneSingleChild(\r\n  children: React.ReactNode | React.ReactNode[],\r\n  props?: Record<string, any>,\r\n  key?: any,\r\n) {\r\n  return React.Children.map(children, (child) => {\r\n    // Checking isValidElement is the safe way and avoids a typescript\r\n    // error too.\r\n    if (React.isValidElement(child) && React.Children.only(children)) {\r\n      return React.cloneElement(child, { ...props, key });\r\n    }\r\n    return child;\r\n  });\r\n}\r\n","/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */\r\n\r\nimport clsx from 'clsx';\r\n\r\n/**\r\n * Calls all functions in the order they were chained with the same arguments.\r\n * @internal\r\n */\r\nexport function chain(...callbacks: any[]): (...args: any[]) => void {\r\n  return (...args: any[]) => {\r\n    for (const callback of callbacks) {\r\n      if (typeof callback === 'function') {\r\n        callback(...args);\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\ninterface Props {\r\n  [key: string]: any;\r\n}\r\n\r\n// taken from: https://stackoverflow.com/questions/51603250/typescript-3-parameter-list-intersection-type/51604379#51604379\r\ntype TupleTypes<T> = { [P in keyof T]: T[P] } extends { [key: number]: infer V } ? V : never;\r\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void\r\n  ? I\r\n  : never;\r\n\r\n/**\r\n * Merges multiple props objects together. Event handlers are chained,\r\n * classNames are combined, and ids are deduplicated - different ids\r\n * will trigger a side-effect and re-render components hooked up with `useId`.\r\n * For all other props, the last prop object overrides all previous ones.\r\n * @param args - Multiple sets of props to merge together.\r\n * @internal\r\n */\r\nexport function mergeProps<T extends Props[]>(...args: T): UnionToIntersection<TupleTypes<T>> {\r\n  // Start with a base clone of the first argument. This is a lot faster than starting\r\n  // with an empty object and adding properties as we go.\r\n  const result: Props = { ...args[0] };\r\n  for (let i = 1; i < args.length; i++) {\r\n    const props = args[i];\r\n    for (const key in props) {\r\n      const a = result[key];\r\n      const b = props[key];\r\n\r\n      // Chain events\r\n      if (\r\n        typeof a === 'function' &&\r\n        typeof b === 'function' &&\r\n        // This is a lot faster than a regex.\r\n        key[0] === 'o' &&\r\n        key[1] === 'n' &&\r\n        key.charCodeAt(2) >= /* 'A' */ 65 &&\r\n        key.charCodeAt(2) <= /* 'Z' */ 90\r\n      ) {\r\n        result[key] = chain(a, b);\r\n\r\n        // Merge classnames, sometimes classNames are empty string which eval to false, so we just need to do a type check\r\n      } else if (\r\n        (key === 'className' || key === 'UNSAFE_className') &&\r\n        typeof a === 'string' &&\r\n        typeof b === 'string'\r\n      ) {\r\n        result[key] = clsx(a, b);\r\n      } else {\r\n        result[key] = b !== undefined ? b : a;\r\n      }\r\n    }\r\n  }\r\n\r\n  return result as UnionToIntersection<TupleTypes<T>>;\r\n}\r\n","import type { VideoSource, AudioSource } from '@livekit/components-core';\r\nimport type { Participant } from 'livekit-client';\r\nimport { useEnsureParticipant } from '../context/participant-context';\r\nimport { useMediaTrackBySourceOrName } from './useMediaTrackBySourceOrName';\r\n\r\n/** @public */\r\nexport interface UseMediaTrackOptions {\r\n  element?: React.RefObject<HTMLMediaElement>;\r\n  props?: React.HTMLAttributes<HTMLVideoElement | HTMLAudioElement>;\r\n}\r\n\r\n/** @public */\r\nexport function useMediaTrack(\r\n  source: VideoSource | AudioSource,\r\n  participant?: Participant,\r\n  options: UseMediaTrackOptions = {},\r\n) {\r\n  const p = useEnsureParticipant(participant);\r\n  return useMediaTrackBySourceOrName({ source, participant: p }, options);\r\n}\r\n","import type { Participant } from 'livekit-client';\r\nimport { useEnsureParticipant } from '../context';\r\nimport type { UseMediaTrackOptions } from './useMediaTrack';\r\nimport { useMediaTrackBySourceOrName } from './useMediaTrackBySourceOrName';\r\n\r\n/** @public */\r\nexport function useMediaTrackByName(\r\n  name: string,\r\n  participant?: Participant,\r\n  options: UseMediaTrackOptions = {},\r\n) {\r\n  const p = useEnsureParticipant(participant);\r\n  return useMediaTrackBySourceOrName({ name, participant: p }, options);\r\n}\r\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useVisualStableUpdate } from './useVisualStableUpdate';\r\n\r\n/**\r\n * The `usePagination` hook implements simple pagination logic for use with arrays.\r\n * @example\r\n * ```tsx\r\n * const tracks = useTracks();\r\n * const pagination = usePagination(4, tracks);\r\n *\r\n * <TrackLoop tracks={pagination.tracks} />\r\n * ```\r\n * @alpha\r\n */\r\nexport function usePagination(itemPerPage: number, trackReferences: TrackReferenceOrPlaceholder[]) {\r\n  const [currentPage, setCurrentPage] = React.useState(1);\r\n  const totalPageCount = Math.max(Math.ceil(trackReferences.length / itemPerPage), 1);\r\n  if (currentPage > totalPageCount) {\r\n    setCurrentPage(totalPageCount);\r\n  }\r\n  const lastItemIndex = currentPage * itemPerPage;\r\n  const firstItemIndex = lastItemIndex - itemPerPage;\r\n\r\n  const changePage = (direction: 'next' | 'previous') => {\r\n    setCurrentPage((state) => {\r\n      if (direction === 'next') {\r\n        if (state === totalPageCount) {\r\n          return state;\r\n        }\r\n        return state + 1;\r\n      } else {\r\n        if (state === 1) {\r\n          return state;\r\n        }\r\n        return state - 1;\r\n      }\r\n    });\r\n  };\r\n\r\n  const goToPage = (num: number) => {\r\n    if (num > totalPageCount) {\r\n      setCurrentPage(totalPageCount);\r\n    } else if (num < 1) {\r\n      setCurrentPage(1);\r\n    } else {\r\n      setCurrentPage(num);\r\n    }\r\n  };\r\n\r\n  const updatedTrackReferences = useVisualStableUpdate(trackReferences, itemPerPage);\r\n\r\n  return {\r\n    totalPageCount,\r\n    nextPage: () => changePage('next'),\r\n    prevPage: () => changePage('previous'),\r\n    setPage: goToPage,\r\n    firstItemIndex,\r\n    lastItemIndex,\r\n    tracks: updatedTrackReferences.slice(firstItemIndex, lastItemIndex),\r\n    currentPage,\r\n  };\r\n}\r\n\r\nexport default usePagination;\r\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\r\nimport { log, sortTrackReferences, updatePages } from '@livekit/components-core';\r\nimport * as React from 'react';\r\n\r\n/** @public */\r\nexport interface UseVisualStableUpdateOptions {\r\n  /** Overwrites the default sort function. */\r\n  customSortFunction?: (\r\n    trackReferences: TrackReferenceOrPlaceholder[],\r\n  ) => TrackReferenceOrPlaceholder[];\r\n}\r\n\r\n/**\r\n * The useVisualStableUpdate hook tries to keep visual updates of the TackBundles array to a minimum,\r\n * while still trying to display important tiles such as speaking participants or screen shares.\r\n *\r\n * Updating works with pagination. For example, if a participant starts speaking on the second page,\r\n * they will be moved to the first page by replacing the least active/interesting participant on the first page.\r\n *\r\n * @beta\r\n */\r\nexport function useVisualStableUpdate(\r\n  /** `TrackReference`s to display in the grid.  */\r\n  trackReferences: TrackReferenceOrPlaceholder[],\r\n  maxItemsOnPage: number,\r\n  options: UseVisualStableUpdateOptions = {},\r\n): TrackReferenceOrPlaceholder[] {\r\n  const lastTrackRefs = React.useRef<TrackReferenceOrPlaceholder[]>([]);\r\n  const lastMaxItemsOnPage = React.useRef<number>(-1);\r\n  const layoutChanged = maxItemsOnPage !== lastMaxItemsOnPage.current;\r\n\r\n  const sortedTrackRefs =\r\n    typeof options.customSortFunction === 'function'\r\n      ? options.customSortFunction(trackReferences)\r\n      : sortTrackReferences(trackReferences);\r\n\r\n  let updatedTrackRefs: TrackReferenceOrPlaceholder[] = [...sortedTrackRefs];\r\n  if (layoutChanged === false) {\r\n    try {\r\n      updatedTrackRefs = updatePages(lastTrackRefs.current, sortedTrackRefs, maxItemsOnPage);\r\n    } catch (error) {\r\n      log.error('Error while running updatePages(): ', error);\r\n    }\r\n  }\r\n\r\n  // Save info for to compare against in the next update cycle.\r\n  if (layoutChanged) {\r\n    lastTrackRefs.current = sortedTrackRefs;\r\n  } else {\r\n    lastTrackRefs.current = updatedTrackRefs;\r\n  }\r\n  lastMaxItemsOnPage.current = maxItemsOnPage;\r\n\r\n  return updatedTrackRefs;\r\n}\r\n","import * as React from 'react';\r\nimport type { Participant } from 'livekit-client';\r\nimport { participantPermissionObserver } from '@livekit/components-core';\r\nimport { useEnsureParticipant } from '../context';\r\nimport { useObservableState } from './internal/useObservableState';\r\n\r\n/** @public */\r\nexport interface UseParticipantPermissionsOptions {\r\n  participant?: Participant;\r\n}\r\n\r\n/** @public */\r\nexport function useParticipantPermissions(options: UseParticipantPermissionsOptions = {}) {\r\n  const p = useEnsureParticipant(options.participant);\r\n  const permissionObserver = React.useMemo(() => participantPermissionObserver(p), [p]);\r\n  const permissions = useObservableState(permissionObserver, p.permissions);\r\n  return permissions;\r\n}\r\n","import { connectedParticipantsObserver } from '@livekit/components-core';\r\nimport type { RoomEvent, RemoteParticipant, Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\n\r\n/** @public */\r\nexport interface UseRemoteParticipantsOptions {\r\n  /**\r\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\r\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\r\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\r\n   */\r\n  updateOnlyOn?: RoomEvent[];\r\n  /**\r\n   * The room to use. If not provided, the hook will use the room from the context.\r\n   */\r\n  room?: Room;\r\n}\r\n\r\n/**\r\n * The useRemoteParticipants\r\n *\r\n * @public\r\n */\r\nexport const useRemoteParticipants = (options: UseRemoteParticipantsOptions = {}) => {\r\n  const room = useEnsureRoom(options.room);\r\n  const [participants, setParticipants] = React.useState<RemoteParticipant[]>([]);\r\n\r\n  React.useEffect(() => {\r\n    const listener = connectedParticipantsObserver(room, {\r\n      additionalRoomEvents: options.updateOnlyOn,\r\n    }).subscribe(setParticipants);\r\n    return () => listener.unsubscribe();\r\n  }, [room, JSON.stringify(options.updateOnlyOn)]);\r\n  return participants;\r\n};\r\n","import type { Room, RoomEvent } from 'livekit-client';\r\nimport { useLocalParticipant } from './useLocalParticipant';\r\nimport { useRemoteParticipants } from './useRemoteParticipants';\r\n\r\n/** @public */\r\nexport interface UseParticipantsOptions {\r\n  /**\r\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\r\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\r\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\r\n   */\r\n  updateOnlyOn?: RoomEvent[];\r\n  /**\r\n   * The room to use. If not provided, the hook will use the room from the context.\r\n   */\r\n  room?: Room;\r\n}\r\n\r\n/**\r\n * The useParticipants hook returns all participants (local and remote) of the current room.\r\n * @public\r\n */\r\nexport const useParticipants = (options: UseParticipantsOptions = {}) => {\r\n  const remoteParticipants = useRemoteParticipants(options);\r\n  const { localParticipant } = useLocalParticipant(options);\r\n\r\n  return [localParticipant, ...remoteParticipants];\r\n};\r\n","import { connectedParticipantObserver } from '@livekit/components-core';\r\nimport type { ParticipantEvent, RemoteParticipant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useRoomContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/** @public */\r\nexport interface UseRemoteParticipantOptions {\r\n  updateOnlyOn?: ParticipantEvent[];\r\n}\r\n\r\n/** @public */\r\nexport const useRemoteParticipant = (\r\n  identity: string,\r\n  options: UseRemoteParticipantOptions = {},\r\n): RemoteParticipant | undefined => {\r\n  const room = useRoomContext();\r\n  const [updateOnlyOn] = React.useState(options.updateOnlyOn);\r\n\r\n  const observable = React.useMemo(\r\n    () => connectedParticipantObserver(room, identity, { additionalEvents: updateOnlyOn }),\r\n    [room, identity, updateOnlyOn],\r\n  );\r\n  const participant = useObservableState(\r\n    observable,\r\n    room.getParticipantByIdentity(identity) as RemoteParticipant | undefined,\r\n  );\r\n  return participant;\r\n};\r\n","import { sortParticipants } from '@livekit/components-core';\r\nimport type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useSpeakingParticipants } from './useSpeakingParticipants';\r\n\r\n/**\r\n * The useSortedParticipants hook returns the only the active speakers of all participants.\r\n *\r\n * @public\r\n */\r\nexport function useSortedParticipants(participants: Array<Participant>) {\r\n  const [sortedParticipants, setSortedParticipants] = React.useState(\r\n    sortParticipants(participants),\r\n  );\r\n  const activeSpeakers = useSpeakingParticipants();\r\n\r\n  React.useEffect(() => {\r\n    setSortedParticipants(sortParticipants(participants));\r\n  }, [activeSpeakers, participants]);\r\n  return sortedParticipants;\r\n}\r\n","import { activeSpeakerObserver } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useRoomContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * The useSpeakingParticipants hook returns the only the active speakers of all participants.\r\n *\r\n * @public\r\n */\r\nexport const useSpeakingParticipants = () => {\r\n  const room = useRoomContext();\r\n  const speakerObserver = React.useMemo(() => activeSpeakerObserver(room), [room]);\r\n  const activeSpeakers = useObservableState(speakerObserver, room.activeSpeakers);\r\n  return activeSpeakers;\r\n};\r\n","import { log } from '@livekit/components-core';\r\nimport * as React from 'react';\r\n\r\n/** @public */\r\nexport interface UserInfo {\r\n  identity?: string;\r\n  name?: string;\r\n  metadata?: string;\r\n}\r\n\r\n/** @public */\r\nexport interface UseTokenOptions {\r\n  userInfo?: UserInfo;\r\n}\r\n\r\n/** @public */\r\nexport function useToken(\r\n  tokenEndpoint: string | undefined,\r\n  roomName: string,\r\n  options: UseTokenOptions = {},\r\n) {\r\n  const [token, setToken] = React.useState<string | undefined>(undefined);\r\n\r\n  React.useEffect(() => {\r\n    if (tokenEndpoint === undefined) {\r\n      throw Error('token endpoint needs to be defined');\r\n    }\r\n    if (options.userInfo?.identity === undefined) {\r\n      return;\r\n    }\r\n    const tokenFetcher = async () => {\r\n      log.debug('fetching token');\r\n      const params = new URLSearchParams({ ...options.userInfo, roomName });\r\n      const res = await fetch(`${tokenEndpoint}?${params.toString()}`);\r\n      const { accessToken } = await res.json();\r\n      setToken(accessToken);\r\n    };\r\n    tokenFetcher();\r\n  }, [tokenEndpoint, roomName, options]);\r\n  return token;\r\n}\r\n","import type {\r\n  SourcesArray,\r\n  TrackReference,\r\n  TrackReferenceOrPlaceholder,\r\n  TrackSourceWithOptions,\r\n  TrackReferencePlaceholder,\r\n} from '@livekit/components-core';\r\nimport {\r\n  isSourcesWithOptions,\r\n  isSourceWitOptions,\r\n  log,\r\n  trackReferencesObservable,\r\n} from '@livekit/components-core';\r\nimport type { Participant, Room, RoomEvent } from 'livekit-client';\r\nimport { Track } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\n\r\n/** @public */\r\nexport type UseTracksOptions = {\r\n  updateOnlyOn?: RoomEvent[];\r\n  onlySubscribed?: boolean;\r\n  room?: Room;\r\n};\r\n\r\n/** @public */\r\nexport type UseTracksHookReturnType<T> = T extends Track.Source[]\r\n  ? TrackReference[]\r\n  : T extends TrackSourceWithOptions[]\r\n  ? TrackReferenceOrPlaceholder[]\r\n  : never;\r\n\r\n/**\r\n * The `useTracks` hook returns an array of `TrackReference` or `TrackReferenceOrPlaceholder` depending on the provided `sources` property.\r\n * If only subscribed tracks are desired, set the `onlySubscribed` property to `true`.\r\n * @example\r\n * ```ts\r\n * // Return all camera track publications.\r\n * const trackReferences: TrackReference[] = useTracks([Track.Source.Camera])\r\n * ```\r\n * @example\r\n * ```ts\r\n * // Return all subscribed camera tracks as well as placeholders for\r\n * // participants without a camera subscription.\r\n * const trackReferencesWithPlaceholders: TrackReferenceOrPlaceholder[] = useTracks([{source: Track.Source.Camera, withPlaceholder: true}])\r\n * ```\r\n * @public\r\n */\r\nexport function useTracks<T extends SourcesArray = Track.Source[]>(\r\n  sources: T = [\r\n    Track.Source.Camera,\r\n    Track.Source.Microphone,\r\n    Track.Source.ScreenShare,\r\n    Track.Source.ScreenShareAudio,\r\n    Track.Source.Unknown,\r\n  ] as T,\r\n  options: UseTracksOptions = {},\r\n): UseTracksHookReturnType<T> {\r\n  const room = useEnsureRoom(options.room);\r\n  const [trackReferences, setTrackReferences] = React.useState<TrackReference[]>([]);\r\n  const [participants, setParticipants] = React.useState<Participant[]>([]);\r\n\r\n  const sources_ = React.useMemo(() => {\r\n    return sources.map((s) => (isSourceWitOptions(s) ? s.source : s));\r\n  }, [JSON.stringify(sources)]);\r\n\r\n  React.useEffect(() => {\r\n    const subscription = trackReferencesObservable(room, sources_, {\r\n      additionalRoomEvents: options.updateOnlyOn,\r\n      onlySubscribed: options.onlySubscribed,\r\n    }).subscribe(({ trackReferences, participants }) => {\r\n      log.debug('setting track bundles', trackReferences, participants);\r\n      setTrackReferences(trackReferences);\r\n      setParticipants(participants);\r\n    });\r\n    return () => subscription.unsubscribe();\r\n  }, [room, JSON.stringify(options.updateOnlyOn), JSON.stringify(sources)]);\r\n\r\n  const maybeTrackReferences = React.useMemo(() => {\r\n    if (isSourcesWithOptions(sources)) {\r\n      const requirePlaceholder = requiredPlaceholders(sources, participants);\r\n      const trackReferencesWithPlaceholders = Array.from(\r\n        trackReferences,\r\n      ) as TrackReferenceOrPlaceholder[];\r\n      participants.forEach((participant) => {\r\n        if (requirePlaceholder.has(participant.identity)) {\r\n          const sourcesToAddPlaceholder = requirePlaceholder.get(participant.identity) ?? [];\r\n          sourcesToAddPlaceholder.forEach((placeholderSource) => {\r\n            if (\r\n              trackReferences.find(\r\n                ({ participant: p, publication }) =>\r\n                  participant.identity === p.identity && publication.source === placeholderSource,\r\n              )\r\n            ) {\r\n              return;\r\n            }\r\n            log.debug(\r\n              `Add ${placeholderSource} placeholder for participant ${participant.identity}.`,\r\n            );\r\n            const placeholder: TrackReferencePlaceholder = {\r\n              participant,\r\n              source: placeholderSource,\r\n            };\r\n            trackReferencesWithPlaceholders.push(placeholder);\r\n          });\r\n        }\r\n      });\r\n      return trackReferencesWithPlaceholders;\r\n    } else {\r\n      return trackReferences;\r\n    }\r\n  }, [trackReferences, participants, sources]);\r\n\r\n  return maybeTrackReferences as UseTracksHookReturnType<T>;\r\n}\r\n\r\nfunction difference<T>(setA: Set<T>, setB: Set<T>): Set<T> {\r\n  const _difference = new Set(setA);\r\n  for (const elem of setB) {\r\n    _difference.delete(elem);\r\n  }\r\n  return _difference;\r\n}\r\n\r\nexport function requiredPlaceholders<T extends SourcesArray>(\r\n  sources: T,\r\n  participants: Participant[],\r\n): Map<Participant['identity'], Track.Source[]> {\r\n  const placeholderMap = new Map<Participant['identity'], Track.Source[]>();\r\n  if (isSourcesWithOptions(sources)) {\r\n    const sourcesThatNeedPlaceholder = sources\r\n      .filter((sourceWithOption) => sourceWithOption.withPlaceholder)\r\n      .map((sourceWithOption) => sourceWithOption.source);\r\n\r\n    participants.forEach((participant) => {\r\n      const sourcesOfSubscribedTracks = participant\r\n        .getTracks()\r\n        .map((pub) => pub.track?.source)\r\n        .filter((trackSource): trackSource is Track.Source => trackSource !== undefined);\r\n      const placeholderNeededForThisParticipant = Array.from(\r\n        difference(new Set(sourcesThatNeedPlaceholder), new Set(sourcesOfSubscribedTracks)),\r\n      );\r\n      // If the participant needs placeholder add it to the placeholder map.\r\n      if (placeholderNeededForThisParticipant.length > 0) {\r\n        placeholderMap.set(participant.identity, placeholderNeededForThisParticipant);\r\n      }\r\n    });\r\n  }\r\n  return placeholderMap;\r\n}\r\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport type { LayoutContextType } from '../context';\r\nimport { useEnsureLayoutContext } from '../context';\r\n\r\n/** @public */\r\nexport function usePinnedTracks(layoutContext?: LayoutContextType): TrackReferenceOrPlaceholder[] {\r\n  layoutContext = useEnsureLayoutContext(layoutContext);\r\n  return React.useMemo(() => {\r\n    if (layoutContext?.pin.state !== undefined && layoutContext.pin.state.length >= 1) {\r\n      return layoutContext.pin.state;\r\n    }\r\n    return [];\r\n  }, [layoutContext]);\r\n}\r\n","import * as React from 'react';\r\n\r\n/**\r\n * @alpha\r\n */\r\nexport type UseSwipeOptions = {\r\n  minSwipeDistance?: number;\r\n  onLeftSwipe?: () => void;\r\n  onRightSwipe?: () => void;\r\n};\r\n\r\n/**\r\n * Simple implementation to detect horizontal swipe actions.\r\n * Accepts callbacks for on right and left swipes.\r\n * @example\r\n * ```tsx\r\n *  <div\r\n      onTouchStart={onTouchStart}\r\n      onTouchMove={onTouchMove}\r\n      onTouchEnd={onTouchEnd}\r\n    >\r\n * ```\r\n * @alpha\r\n */\r\nexport function useSwipe(element: React.RefObject<HTMLElement>, options: UseSwipeOptions = {}) {\r\n  const touchStart = React.useRef<number | null>(null);\r\n  const touchEnd = React.useRef<number | null>(null);\r\n\r\n  // The required distance between touchStart and touchEnd to be detected as a swipe.\r\n  const minSwipeDistance = options.minSwipeDistance ?? 50;\r\n\r\n  const onTouchStart = (event: TouchEvent) => {\r\n    touchEnd.current = null; // Otherwise the swipe is fired even with usual touch events.\r\n    touchStart.current = event.targetTouches[0].clientX;\r\n  };\r\n\r\n  const onTouchMove = (event: TouchEvent) => {\r\n    touchEnd.current = event.targetTouches[0].clientX;\r\n  };\r\n\r\n  const onTouchEnd = React.useCallback(() => {\r\n    if (!touchStart.current || !touchEnd.current) {\r\n      return;\r\n    }\r\n    const distance = touchStart.current - touchEnd.current;\r\n    const isLeftSwipe = distance > minSwipeDistance;\r\n    const isRightSwipe = distance < -minSwipeDistance;\r\n\r\n    if (isLeftSwipe && options.onLeftSwipe) options.onLeftSwipe();\r\n    if (isRightSwipe && options.onRightSwipe) options.onRightSwipe();\r\n  }, [minSwipeDistance, options]);\r\n\r\n  React.useEffect(() => {\r\n    const elementCopy = element.current;\r\n    if (elementCopy) {\r\n      elementCopy.addEventListener('touchstart', onTouchStart);\r\n      elementCopy.addEventListener('touchmove', onTouchMove);\r\n      elementCopy.addEventListener('touchend', onTouchEnd);\r\n    }\r\n    return () => {\r\n      if (elementCopy) {\r\n        elementCopy.removeEventListener('touchstart', onTouchStart);\r\n        elementCopy.removeEventListener('touchmove', onTouchMove);\r\n        elementCopy.removeEventListener('touchend', onTouchEnd);\r\n      }\r\n    };\r\n  }, [element, onTouchEnd]);\r\n}\r\n"],"mappings":"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","names":["import_components_core","React","React","React","React","React","useLatest","React","import_components_core","React","import_components_core","React","import_components_core","React","import_components_core","React","import_components_core","React","import_components_core","React","React","clsx","mergeProps","publication","mergeProps","React","import_components_core","React","React","import_components_core","import_components_core","React","import_components_core","React","import_components_core","React","import_components_core","React","import_components_core","React","import_components_core","import_livekit_client","React","trackReferences","participants","React","React"]}